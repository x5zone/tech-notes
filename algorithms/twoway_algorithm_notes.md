# Two-Way 字符串匹配算法：程序员视角的推导笔记
*The Two-Way Matching Algorithm: A Programmer's Perspective*

---

## 目录

- [引论](#引论)
- [一、代码总览](#一代码总览)
- [二、核心概念](#二核心概念)
  - [2.1 最大后缀（Maximal Suffix）](#21-最大后缀maximal-suffix)
  - [2.2 两个方向的最大后缀](#22-两个方向的最大后缀)
  - [2.3 最大后缀的直观理解](#23-最大后缀的直观理解)
- [三、maxSuf 函数详解](#三maxsuf-函数详解)
  - [3.1 核心比喻：擂台赛模型](#31-核心比喻擂台赛模型)
  - [3.2 关于 maxSuf 的阅读视角](#32-关于-maxsuf-的阅读视角)
  - [3.3 变量释义](#33-变量释义)
  - [3.4 三种情况概览](#34-三种情况概览)
  - [3.5 情况1：挑战者失败（a < b）](#35-情况1挑战者失败a--b)
  - [3.6 情况2：势均力敌（a == b）](#36-情况2势均力敌a--b)
  - [3.7 情况3：挑战者获胜（a > b）](#37-情况3挑战者获胜a--b)
  - [3.8 双向最大后缀的预处理](#38-双向最大后缀的预处理)
- [四、TW 函数详解](#四tw-函数详解)
  - [4.1 周期性的判断（memcmp(x, x + per, ell + 1)）](#41-周期性的判断memcmpx-x-per-ell-1)
  - [4.2 周期性搜索分支](#42-周期性搜索分支)
  - [4.3 非周期性搜索分支](#43-非周期性搜索分支)
- [五、总结](#五总结)
  - [5.1 核心流程](#51-核心流程)
  - [5.2 关键结论](#52-关键结论)
  - [5.3 与其他算法对比](#53-与其他算法对比)
- [版权说明](#版权说明)

---

## 引论

- **问题背景**
  - 在介绍 Two-Way 算法时，多数算法教程往往直接从“临界分解定理”（Critical Factorization Theorem）和“周期”（Period）等数学结论切入。然而从工程实现出发，往往难以将这些数学原理与代码逻辑对应起来，造成理解上的困难。
  - 在预处理阶段（即 `maxSuf` 函数），算法并不是一上来就在"寻找周期"，而是通过字典序比较，逐步排除一整段**必然失败的位移范围**。每一次比较的结果，都会让一部分模式串右移尝试被永久否定。算法中维护的一个核心位移变量（即 `p`），记录的正是当前已知信息下仍有可能成功的最小位移界限——所有小于该跨度的右移，都已经被证明必然失败，无需再尝试。
  - 从程序员的视角看，字符串搜索算法中最直观的操作，就是不断决定"模式串能否继续右移、以及最少要右移多少"。为了贴合这种直觉，本文将这类已被证明可以直接跳过的位移范围，非正式地称为**安全跳跃距离**（Safe Shift Distance）。
  - 关于"周期"这一数学概念，本文不将其作为预设前提强行引入，而是让它在算法推进过程中，作为跳跃决策在局部范围内自然显现的结构性质逐步浮现。这样，工程上的决策逻辑与数学结构之间的联系，才能以更易理解的方式呈现。

- **本文定位**
  - 本文从程序员视角出发，通过字典序约束和几何位移分析，把 Two-Way 还原为一系列可执行的工程决策：
    - 哪些位移已被证明必然失败、可以直接跳过。
    - 哪些位置仍有可能匹配成功、需要继续尝试。
    - 为什么整套流程在 $O(1)$ 额外空间下依然可以保证 $O(n)$ 的时间复杂度。
  - 作为 Rust 初学者，我在阅读《[Inside Rust Std Library](https://github.com/Warrenren/inside-rust-std-library)》一书时接触到了 Two-Way 算法。通过网络搜索和 AI 讲解资料，发现往往泛泛而谈或过于数学化，难以透彻理解代码，遂记录下个人的推导与理解过程。

- **算法价值**
  - Two-Way 算法已成为字符串匹配领域的重要工程实现——Rust 标准库、glibc 和 Go 的内部实现均采用此算法，极具学习与研究价值。
  - 与 KMP 的前缀函数和 BM 的启发式相比，Two-Way 在 $O(1)$ 空间内实现确定性的 $O(n)$ 时间匹配，同时避免频繁的状态回退与复杂的预处理表，缓存更友好、运行更稳定，更适合作为标准库级别的通用实现。

- **参考来源**
  - 本文参考了 [Two-Way C Implementation](https://www-igm.univ-mlv.fr/~lecroq/string/node26.html#SECTION00260)，这是一份权威的 C 语言实现，本文将以此代码为基准。

---

## 一、代码总览

- **阅读提示**
  - 可先快速浏览本节代码，后续章节会逐行拆解其含义。

- **maxSuf 函数（在 `≤` 字典序下的最大后缀）**
  ```c
    /* Computing of the maximal suffix for <= */
    int maxSuf(char *x, int m, int *p) {
       int ms, j, k;
       char a, b;

       ms = -1;
       j = 0;
       k = *p = 1;
       while (j + k < m) {
          a = x[j + k];
          b = x[ms + k];
          if (a < b) {
             j += k;
             k = 1;
             *p = j - ms;
          }
          else
             if (a == b)
                if (k != *p)
                   ++k;
                else {
                   j += *p;
                   k = 1;
                }
             else { /* a > b */
                ms = j;
                j = ms + 1;
                k = *p = 1;
             }
       }
       return(ms);
    }
    ```

- **maxSufTilde 函数（在 `≥` 字典序下的最大后缀）**
  ```c
    /* Computing of the maximal suffix for >= */
    int maxSufTilde(char *x, int m, int *p) {
       int ms, j, k;
       char a, b;

       ms = -1;
       j = 0;
       k = *p = 1;
       while (j + k < m) {
          a = x[j + k];
          b = x[ms + k];
          if (a > b) {
             j += k;
             k = 1;
             *p = j - ms;
          }
          else
             if (a == b)
                if (k != *p)
                   ++k;
                else {
                   j += *p;
                   k = 1;
                }
             else { /* a < b */
                ms = j;
                j = ms + 1;
                k = *p = 1;
             }
       }
       return(ms);
    }
    ```

- **Two-Way 主算法**
  ```c
    /* Two Way string matching algorithm. */
    void TW(char *x, int m, char *y, int n) {
       int i, j, ell, memory, p, per, q;

       /* Preprocessing */
       i = maxSuf(x, m, &p);
       j = maxSufTilde(x, m, &q);
       if (i > j) {
          ell = i;
          per = p;
       }
       else {
          ell = j;
          per = q;
       }

       /* Searching */
       if (memcmp(x, x + per, ell + 1) == 0) {
          j = 0;
          memory = -1;
          while (j <= n - m) {
             i = MAX(ell, memory) + 1;
             while (i < m && x[i] == y[i + j])
                ++i;
             if (i >= m) {
                i = ell;
                while (i > memory && x[i] == y[i + j])
                   --i;
                if (i <= memory)
                   OUTPUT(j);
                j += per;
                memory = m - per - 1;
             }
             else {
                j += (i - ell);
                memory = -1;
             }
          }
       }
       else {
          per = MAX(ell + 1, m - ell - 1) + 1;
          j = 0;
          while (j <= n - m) {
             i = ell + 1;
             while (i < m && x[i] == y[i + j])
                ++i;
             if (i >= m) {
                i = ell;
                while (i >= 0 && x[i] == y[i + j])
                   --i;
                if (i < 0)
                   OUTPUT(j);
                j += per;
             }
             else
                j += (i - ell);
          }
       }
    }
    ```

---

## 二、核心概念

### 2.1 最大后缀（Maximal Suffix）

- **定义**
  - 字符串 `x` 的一个后缀，满足该后缀在字典序（`≤` 或 `≥`）上大于 `x` 的其他所有后缀。

- **例子**
  ```
  对于字符串 "abcye"，它的后缀为：
  "abcye"、"bcye"、"cye"、"ye"、"e"
  其中字典序（`≤`）最大后缀为 "ye"。

  对于字符串 "cabcabcab"，它的后缀为：
  "cabcabcab"、"abcabcab"、"bcabcab"、"cabcab"、
  "abcab"、"bcab"、"cab"、"ab"、"b"
  其中字典序（`≤`）最大后缀为 "cabcabcab"。
  ```

- **重要说明**
  - 空字符 `""` 也被认为是一个后缀，且字典序最小（无论在 `≤` 或 `≥` 字典序下）。
  - **“最长串获胜”原则（或“短串必败”原则）**：
    - **核心逻辑**：在字典序比较中，如果短串 $A$ 恰好是长串 $B$ 的前缀，且 $B$ 为最大后缀，那么因空字符最小，较长的串 $B$ 必然大于短串 $A$。
    - **周期性中的应用**：该原则在处理**周期性重复**时威力巨大。如果字符串具有周期 $p$，那么起始位置相差 $p$ 的两个后缀在**当前可比范围内**必然共享相同的前缀。只要这种周期性在当前比较范围内不断裂，起始位置更早的后缀（更长的串）就会因为“多出一个周期单元”而始终在字典序上胜过较短的后缀。
    - **例子**：在 `"cabcabcab"` 中，后缀 `"cabcab"` 和 `"cab"` 都是最大后缀 `"cabcabcab"` 的前缀。因为它们共享 `cab` 这一周期单元，最长的串（包含 3 个单元）必然获胜。在后续算法推导过程中，我们将大量依赖这一性质来排除无效位移、确定安全跳跃距离。

### 2.2 两个方向的最大后缀

- **两种计算方向**
  - **maxSuf**：基于字典序（`≤`方向）的最大后缀。
  - **maxSufTilde**：基于字典序（`≥`方向）的最大后缀。

- **基础性质**
  - 空字符 `""` 在任意字典序比较中都小于其他字符。

### 2.3 最大后缀的直观理解

- 下述内容是一种帮助理解的直觉模型，而非形式化定义。

- **曲线可视化**
  - 字符串按照字典序可以形象化为一条曲线：
  ```
      /\
     /  \
    /    \  /
          \/
  ```
  - 字符串中每个位置的字符值可以形象化为曲线的高度，整个字符串呈现多个波峰和波谷。

- **波峰与波谷的对应关系**
  - 最大波峰对应字典序升序（`≤`方向）的临界分解点（`maxSuf`），最大波谷对应字典序降序（`≥`方向）的临界分解点（`maxSufTilde`）。 
  - 这些关键点就像模式字符串中的"刺头"——它们是字典序的极值点，与周围字符形成鲜明对比。当它们与搜索串中已匹配的"镜像串"对齐时，一旦右移跳跃，极值特性往往会导致字符冲突。抓住它们的规律，就能在匹配过程中排除显然无效的位移，从而更有针对性地选择跳跃步数。

- **镜像串的作用**
  - 搜索串的字符是完全未知的，它既可能大于波峰，也可能小于波谷。但一旦我们匹配了若干字符，这部分已匹配的字符就构成了“镜像串”——它来源于模式串，字符是已知的。如果此时将波峰或波谷与镜像串随意移动对齐，往往会在比较早的位置发生不匹配。因此，关键在于分析模式串的信息，计算出合理的跳跃步数。

- **应用示例**
  - 例如：模式串 `S` 的最大波峰位于位置 `i`，最大波谷位于位置 `j`。假设我们已经匹配了若干字符，构成了镜像串。如果右移步数不恰当，模式串中的"刺头"就会对准镜像串中的字符，而"刺头"的极值特性通常会导致匹配失败。因此，更明智的做法是根据"刺头"和镜像串之间的关系，排除一批显然无效的位移，再在剩余候选中确定安全跳跃距离——所有的"魔法"，都隐藏在刺头字符与镜像串的互动之中。

---

## 三、maxSuf 函数详解


### 3.1 核心比喻：擂台赛模型

- 为了直观理解 `maxSuf` 的运行逻辑，我们可以将其想象成一场**动态擂台赛**。下述模型是一种帮助理解控制流的工程直觉，而非形式化定义。

- **擂主（ms）**
  - 代表“到目前为止发现的最佳人选”。准确地说，`ms+1` 是当前已知的最大后缀起点。擂主占据着高地，等待后续的挑战。
- **挑战者（j）**
  - 代表“潜在的新秀”。算法不断向右移动 `j`，寻找是否有一个新的位置作为起点，能产生字典序更大的后缀。
- **战斗回合（k）**
  - 代表“实力的深度较量”。挑战者 `j` 与擂主 `ms` 逐个字符向后比对。比对得越久（`k` 越大），说明挑战者的潜力越接近擂主。
- **博弈规则**
  - **挑战失败（a < b）**：挑战者在某个深度暴露了弱点（字典序更小），不仅自己被淘汰，而且从当前位置到 `j+k` 的所有候选起点也因拖累而一并被排除。
  - **势均力敌（a == b）**：双方暂时打平，继续向后比对。
  - **挑战成功（a > b）**：挑战者展现出了更强的实力（字典序更大），直接取代旧擂主，自己成为新擂主，并重置赛场。

### 3.2 关于 maxSuf 的阅读视角

- **函数定位**
  - 在 Two-Way 字符串匹配算法中，maxSuf 常被称为"预处理阶段"的核心函数。
  - 它的输出是两个量：最大后缀的切分点 ms，以及一个整数变量 p。

- **理解难点**
  - 需要明确指出：maxSuf 并不是一个可以脱离上下文独立理解的函数——它的设计目标是为搜索阶段提供关键信息，而非单独成立。
  - 如果仅在 maxSuf 的函数体内部理解它的行为，尤其是变量 p 的构造过程，往往会产生强烈困惑：
    - 为什么某些挑战者位置可以被直接跳过？
    - 为什么在字符相等（a == b）时，算法有时会执行大步移动？
    - 为什么 p 的更新方式看起来既不像"长度"，也不像"周期"？

- **正确视角**
  - 这些问题的根源在于：maxSuf 的设计目标本就不是"独立完成某个计算任务"，而是为搜索阶段提供关键信息。
  - 接下来的小节中，我们将不再把 maxSuf 当作一个"孤立的字符串比较算法函数"，而是把它放回 Two-Way 算法的整体流程中，从搜索阶段的需求来回看它的每一个设计选择。
  - 需要强调的是：这一视角切换并不会改变 maxSuf 的计算过程，也不会引入新的假设。

### 3.3 变量释义

- **函数签名**
  ```c
    int maxSuf(char *x, int m, int *p)
  ```

  - **输入输出参数**
    - | 参数 | 含义 |
      |-----|------|
      | `x` | 模式串 |
      | `m` | 模式串长度 |
      | `p` | 输出参数：安全跳跃距离（Safe Shift Distance），在后续搜索阶段可能被验证为周期 |

  - **核心变量**
    - | 变量 | 含义 | 形象比喻 |
      |-----|------|---------|
      | `ms` | 最大后缀起点的前一个位置 | 擂主 |
      | `j` | 当前比较的起点的前一个位置 | 挑战者 |
      | `k` | 当前比较的偏移量 | 战斗回合数 |
      | `*p` | 擂主与当前挑战者之间的间距（即 `j - ms`） | 安全跳跃距离 |

  - **比较变量**
    - | 变量 | 含义 |
      |-----|------|
      | `a` | 挑战者字符 `x[j + k]` |
      | `b` | 擂主字符 `x[ms + k]` |

  - **图示理解**
    - 
    ```
      pos:   0    1    2    3    4    5    6    7    8
      char:  a    b    c    y    a    b    c    y    d
                      ^              ^
                      ms             j
    ```
    - `ms + 1` 才是真正的最大后缀起点
    - 正在比较的是 `x[ms + k]` 和 `x[j + k]`

### 3.4 三种情况概览

- **整体理解**
  - 整个 while 循环就是一个持续不断的擂台赛，指针 `j` 像一个个的挑战者，不断寻找战胜旧擂主 `ms` 的机会。

- **三种情况对照表**
  - | 情况 | 代码 | 直观理解 |
    |-----|------|---------|
    | **a < b** | `j += k; k = 1; *p = j - ms;` | **挑战失败**：挑战者太弱，不仅自己输了，从当前位置到 `j+k` 的所有候选起点也一并被排除。 |
    | **a == b** | `k++` 或 `j += *p` | **势均力敌**：双方打平。若 `k < *p` 则继续深入比较（`k++`）；若 `k == *p` 则利用已知的重复结构跳过已验证区间（`j += *p`）。 |
    | **a > b** | `ms = j; j = ms + 1; k = *p = 1;` | **挑战成功**：挑战者更强，成为新擂主，开启新的擂台赛。 |

### 3.5 情况1：挑战者失败（a < b）


- **代码**
  ```c
    if (a < b) {
      j += k;          // j 移动到新的比较起点
      k = 1;           // 重置偏移量
      *p = j - ms;     // 本函数内唯一的安全跳跃距离赋值处
    }
  ```


#### 3.5.1 为什么 `j += k`？

  - **一句话总结**
    - 从 `j + 1` 到 `j + k` 的所有候选起点都必败，没有挑战的必要，可以直接跳过。

  - **证明**
    - **引理**：在 maxSuf 的字典序比较中，x[ms+1] >= x[ms+2..ms+k-1] 恒成立
      - 证明：如果 x[ms+2..ms+k-1] 中有字符比 x[ms+1] 更大，那么它应该是擂主的首字符，但实际上它不是，故引理成立
    - 已知条件：x[ms+1..ms+k-1] = x[j+1..j+k-1]，且本分支进入条件为 x[j+k] < x[ms+k]，即 a < b
      - 注：若从情况3（a > b）进入本分支，会执行 ms = j; j = ms + 1; k = *p = 1 重启比赛，该情形较为简单，此处不再赘述
    - 从引理可得：x[ms+1] >= x[ms+2..ms+k-1]（首字符大于等于后续每个字符）
    - 结合等式关系可知：x[j+1] >= x[j+2..j+k-1]
    - 这说明从 j+1 到 j+k-1 的每一个位置作为起点时，其首字符都不大于 j+1 的首字符
    - 由于 j+1 在第 k 处已经失败（x[j+k] < x[ms+k]），这些更靠后的位置只会更早失败或同样失败

  - **历史回溯视角（同一论证的不同视角）**
    - 算法的循环是从左向右移动 j 的，这意味着任何小于当前 j 的位置都已经在历史上作为挑战者失败过了
    - 假设尝试从 j+d（1 ≤ d < k）开始挑战，由于 x[j+d...] 作为 x[ms+d...] 的"短版本"，在同一区间内也绝无获胜可能
    - 因此与其重复历史上已经失败过的路径，不如直接跳过这 k 个无效起点

  - **为什么是 j += k？**
    - 既然这 k 个位置都没有夺冠可能，直接执行 `j += k`
    - **陷阱提示**：执行 `j += k` 后，新的挑战者起点是 `j + 1`（因为 j 已更新），而非 `j`。这是一个容易忽略的"+1"偏移陷阱。

#### 3.5.2 为什么 `k = 1`？

  - 新的挑战者上台，因为它是新的比较起点，计步器变量 k 需要重置为 1

#### 3.5.3 p 的困惑与澄清

  - **困惑：p 到底是什么？**
    - 很多人看到 period 这个命名，直觉上会认为它必须对应某种重复。但 p 记录的仅仅是擂主和新挑战者之间的间距，与"重复结构"无关。
      - 前文论证中，曾提过 x[ms+1..ms+k-1] = x[j+1..j+k-1]，这说明 ms+1 到 ms+k-1 这 k-1 个字符，与 j+1 到 j+k-1 这 k-1 个字符完全相同。这会引入情况2和变量k，于是对 p、k 以及为何称其为周期更加困惑。
    - `*p` = j - ms 是由擂台赛历史产生的安全位移界，它保证在该字典序方向下，所有小于 p 的位移都会落入已被否定的区域。
    - **p 的真正含义是：根据当前已知不匹配信息，能够安全滑过的最小距离。**

  - **Two-Way 预处理阶段的真正目的**
    - maxSuf 预处理阶段只做一件事：**结构筛选**——找出一个切分点 ell 和位移 p，使得任何更小的位移都会破坏该切分点两侧的字典序极值结构。
    - 换句话说，预处理阶段并不是在"计算周期"，而是在**排除不可能成为起点的结构区间**。

  - **知识背景预告**
    - Two-Way 算法将模式串切分为两个部分 (L|R)，L 为模式串的前缀，R 为模式串的后缀。maxSuf 函数其实是在寻找 R，并计算其安全跳跃距离。在搜索扫描过程中，会先将模式串的 R 与搜索串从左向右匹配比较，之后将 L 与搜索串从右向左匹配比较。

#### 3.5.4 几何对齐与安全跳跃证明

  - 当模式串的右半部分 R 与搜索串匹配成功时，搜索串对应区域就成了 R 的"镜像区"。我们在预处理阶段得到的**安全跳跃距离**，只有在 R 与搜索串完全匹配、但 L 匹配失败时，才会作为跳跃的依据。

  - **几何对齐示意图（假设 ms 之后的 R 已经匹配）**

      ```
      搜索串 (y):  [--- L ---][--- R (已匹配镜像区) --b][--- 未来未知区 ---]
      模式串 (旧):            |--------- R ---------b|
      模式串 (新):            |---- d ----|--------- R ---------|
      ```

  - **核心问题**
      - 此时，我们已知搜索串对应区间的字符分布。如果接下来的匹配失败（比如左半部 L 不匹配），我们需要右移模式串。问题的核心在于：右移多少才是安全的？上图中的跳跃 d 是否是一个**安全跳跃距离**？

  - **为什么 `*p = j - ms` 是最小安全跳跃距离？**

    - **核心证明目标**
      - 从几何对齐角度看，如果做一个小位移 d（1 ≤ d < p），模式串的 R 前缀会与搜索串镜像区中的 R 后缀进行匹配。历史上，这些 R 后缀正是因为与擂主比较时"小于"擂主而被击败，从而在镜像区中留下"小于"关系的确切证据——只要敢滑过去对齐，就注定触发字符冲突。我们需要证明：在 $p = j - ms$ 确定的瞬间，所有小于 p 的挑战者（候选位移 d）都已被证伪。

    - **挑战者分类**
      - 我们可以把这些“小于 p 的挑战者”分为两类：

      - **第一类：跳跃 d 后触发字符冲突**
        - 如图所示，这本质上是擂主 **R 的前缀**（右移后的模式串）与挑战者 **R 的后缀**（镜像区剩余）在博弈。由于最大后缀定义要求 R 前缀 $\ge$ R 后缀，而本类情况限定了“不相等”，故 R 前缀必然在某处大于 R 后缀。这种字符冲突证伪了位移 $d$，当前的 $p$ 依然安全。

      - **第二类：跳跃 d 后保持字符相等（潜在重复结构）**
        - 跳跃 $d$ 之后，**R 前缀**与镜像区剩余字符完全相等（即模式串右移后，R 前缀对齐了镜像区的 R 后缀）。这种情况符合最大后缀“前缀 $\ge$ 后缀”的定义。如果位移 $d$ 真的存在，它将是推翻“当前 $p$ 是安全跳跃距离”假设的唯一可能——即成功通过了镜像区约束，使匹配得以在未知区继续进行，最终有可能找到匹配。

    - **深入分析——证明第二类 d 根本不存在**
      - 为了彻底排除第二类 d ，我们需要拆开分析 $(ms, j)$ 这个完整区间，证明无论位移 $d$ 落在何处，最终都会被算法逻辑彻底证伪。

      - **回顾 `maxSuf` 执行历史**
        - 在算法运行过程中，区间 $(ms, j)$ 内的每一个位置都曾作为挑战者起点。
      - **跳跃后的位置关系**
        - 跳跃 $d$ 后，模式串R的起始位置移动到了 $ms+d+1$。此时，镜像区（搜索串中已匹配的部分）的 **R 后缀**将与 **R 前缀**重合。接下来分两种情况分析：
          1. 新起点落在闭区间 $[ms+2, j_{old}]$
          2. 新起点落在闭区间 $[j_{old}+1, ms+p]$（d 最大 = p-1，新起点 = ms + p）
        - 落点图示:
        ```
        搜索串 (y):  [--- L ---][--- R (已匹配镜像区) --b][--- 未来未知区 ---]
                                    |     |     |
                                   落点   j_old 落点
        ```

      - **起点落在闭区间 $[ms+2, j_{old}]$**
        - $ms+2$ 到 $j_{old}$ 之间的每个位置都曾是某个挑战者的起始字符，这些挑战者都在历史循环中落败。
          - 失败的挑战者有两种原因：一是因 a < b 落败；二是因字符相等而一直打平，直到退出while循环时因短串而失败。
        - 既然挑战者 j 已演进到现在的 $j_{old}$（起始字符为 $j_{old}+1$），说明这些位置并非因"够不到结尾"而失败，而是在模式串内部就撞到了比自己大的字符。因为挑战者 j 存在，说明这些位置必定失败且只会比挑战者 j 更早失败，失败原因必是实打实的 a < b 导致的提前失败。因此，镜像区的匹配长度足以覆盖这些失配位置，从而确保失配。

      - **起点落在闭区间 $[j_{old}+1, ms+p]$**
        - **序列重合观察**：此区间的挑战者序列满足 `x[ms+1…ms+k-1] = x[j_old+1…j_old+k−1]`，即它们与模式串的 **R 前缀区**具有相同的内容。
        - **利用最大后缀性质进行论证**：
           - 1. **局部失配论证**。由于守尾字符的存在（触发 `if (a < b)` 分支），有 $x[ms+k] > x[j_{old}+k]$。对于给定位移 $d$，其序列与历史比对区间同源，满足 $x[ms+d..ms+k-1] = x[j_{old}+d..j_{old}+k-1]$，可得 $x[ms+d..] > x[j_{old}+d..]$。
           - 2. **性质引入**。根据最大后缀定义，对于 $d \ge 1$，有 $x[ms+1..] \ge x[ms+d..]$。
           - 3. **链式推导**。综上得不等式链：**$x[ms+1..] \ge x[ms+d..] > x[j_{old}+d..]$**。
           - **结论**：在镜像区范围内，任何位移 $d$ 都会因撞上守尾字符（预设的字符冲突点）而失效。

    - **关键补充**
      - 这里有一个关键推论：**失败的短串必然已比对至模式串末尾**。对应代码中的 `while (j + k < m)` 条件——只要循环还在进行，就说明尚未触及模式串尽头。未到尽头就触发 `if (a < b)`，说明挑战者因"字符较小"而失配。若短串是因"字符相等"而落败（即 `while` 循环正常结束），根据 `maxSuf` 定义，它必是比对到模式串最后一个字符后，因后续无字符可比才停止。`while` 循环不走回头路，一旦出现短串，预处理过程也即将收尾。
      - 尝试构造例子是帮助理解算法的好方法。例如针对模式串 `"cbacbacba"`，其最小安全位移 $p=3$。然而从位置 3 开始，就再也不会进入到 `if (a < b)` 这个分支了，该距离不会被破坏。

    - **总结：谜底就在谜面上**
      - 为什么这个 p 是最小安全跳跃距离？

      - **头部压制**
        - `x[ms]` 作为"刺头字符"（波峰），保证了其后的一段范围内没有对手。

      - **尾部拦截**
        - `if (a < b)` 这个判断条件，精准地在模式串内部制造了一个**"守尾字符"**（失配锚点）。

      - **结论**
        - 任何小于 $p$ 的跳跃，要么会被头部的“刺头字符”压制，要么会被尾部的“失配锚点”拦截。进入 `if (a < b)` 分支，意味着我们不仅找到了新起点 $j$，还锁死了从 $ms$ 到 $j$ 之间所有的可能性。此时的 $p = j - ms$ 展现出其作为“安全跳跃距离”的确定性。

#### 3.5.5 安全跳跃距离与周期的关系

  - 前文已证明：对于任意 1 ≤ d < p，把模式串向右平移 d 位都会立刻产生冲突。因此 p 被称为"安全跳跃距离"。在 `maxSuf` 预处理阶段，p 的核心身份就是安全跳跃距离。
  - 但从数学定义看，这恰好也是**最小周期**的定义——子串内部不含更小周期，否则平移 d 位能成功而非冲突。例如模式串 `"cba"` 的 p 值为 3，最小周期也是 3，重复次数为 1。因此，p 值本质上是该子串重复次数为 1 时的最小周期。
    - 在擂主不变的前提下（即仅包含情况1和情况2）：
      - 情况1：a < b，发现新冲突点且挑战者字符更小，安全跳跃距离直接更新变大。
      - 情况2：a == b，重合字符用 k 计数，这种情况不改变 p，但可能因循环退出而终止。情况2最容易让人联想到"周期"概念——重复结构，如 `"cbac"`、`"cbacb"`、`"cbacbacba"`。
  - 因此，`maxSuf` 退出后，也可称 p 值为 R 的最小周期。
  - 至于 p 能否升级为模式串的 **Period**（周期），取决于后续搜索阶段中，算法能否通过 `memcmp` 验证这一局部规律在前缀 L 上同样适用。若验证成功，p 将完成从"R最小周期"到"全局周期"的身份转变。

### 3.6 情况2：势均力敌（a == b）

- **代码逻辑**
  ```c
    if (a == b)
       if (k != *p)
          ++k;              // 计数器增加
       else {
          j += *p;          // 跳过一个已验证的重复候选结构
          k = 1;            // 重置计数器
       }
  ```

- **整体理解**
  - 情况2是挑战者和擂主打成平手。语义层面上，它并不会改变"谁是最大后缀"的判断，也不会改变安全跳跃距离 p；但在工程层面，算法借此机会利用局部重复信息做一次效率优化，避免在高度重复的区域里做过多无谓的比较。

#### 3.6.1  p 的概念与动态变化
  - p = j - ms，即擂主与"当前仍具挑战资格"最左起点之间的距离。

  - **关于"period"一词的说明**
    - **初学者困惑**：既然 p 在大多数文献中被称为"周期（period）"，而 k 代表当前探测到的重复长度，**p 为什么不记录 k？** p 的值为何不随 k 增长而更新？
    - **语义陷阱**："周期"暗示"既定的、正在发生的重复"。带着这种心态阅读代码，会发现 p 的更新逻辑难以理解。
    - **事实澄清**：p 与 k 并无直接关联。p 在 maxSuf 中，始终是擂主与"当前仍具挑战资格"最左起点之间的距离。若 a == b 分支仅做计数器增加操作，也只影响 maxSuf 的效率，不影响最终正确性。
    - **a == b 分支的本质**：当出现 a == b 时，算法发现当前区域呈现周期性重复迹象。这不是在证明"这是周期"，而是说当前安全跳跃距离 p 尚未被破坏——当前现象仍成立（打平需继续比较）。本分支代码与周期概念无直接关联，例如模式串 `"aaaaaa..."`，k 在本分支内无限增长，p 也不会改变。
    - **核心本质**：p 在 maxSuf 逻辑中，本质不是记录"已重复多长（进度）"，而是记录"**位移在多少以内是必然冲突的（底线）**"——这正是本笔记引入"安全跳跃距离"这一名词的原因。前文已论述安全跳跃距离与最小周期是等价名词，只是本分支代码与周期概念无关。

  - **p 值变化总结**
    - **情况1（a < b）**：p 增大（p = j - ms，擂主 ms 不变时 j 始终向右移动，故 p 随之增大）
    - **情况2（a == b）**：p 保持不变
    - **情况3（a > b）**：p 重置归 1

#### 3.6.2  a == b 分支的完整逻辑

- **代码**
  ```c
  if (a == b)
     if (k != *p)
        ++k;              // 继续探测
     else {
        j += *p;          // 跳过已验证的重复结构
        k = 1;            // 重置计数器
     }
  ```

- **k < p：继续逐字符比较**
  - 此时比较的是擂主串内部位置与挑战者串对应位置
  - 若相等 → 挑战者仍在"复刻"擂主结构，继续比较
  - 若不等 → 触发情况1或情况3，更新 p 或更换擂主

- **k == p：发现重复副本**
  - 当比较偏移量 k 达到 p 时，说明挑战者从起点到当前位置的字符序列与擂主完全相同——挑战者是擂主的一个重复副本。
  - **最长串获胜**：擂主作为更长的串，字典序上必胜，挑战者无需继续比较。
  - 直接跳到 `j + p`。因为任何位移 d < p 的位置，在擂主赛历史中都曾作为挑战者起点，且都已失败——它们要么因 a < b 落败，要么因打平后被更长串淘汰。这些是"必败起点"，无需再次尝试。

- **例子说明**
  - 模式串 `"cbacbacba"`，ms = -1，j = 2，p = 3
    ```
    位置:  0  1  2  3  4  5  6  7  8
    字符:  c  b  a  c  b  a  c  b  a
          ^        ^
          ms       j (p = 3)
    ```
  - k = 1: x[1] vs x[4] (b == b) → ++k
  - k = 2: x[2] vs x[5] (a == a) → ++k
  - k = 3: k == p，前缀 `"cba"` 完全匹配 → j += 3，跳到位置 5

- **跳跃的效率意义**
  - **线性保证**：j 只向右跳跃，永不回退，确保 maxSuf 复杂度为 $O(m)$。
  - **防止退化**：若无此跳跃，在 `"aaaaaa..."` 等高度重复串上，复杂度会退化为 $O(m^2)$。

### 3.7 情况3：挑战者获胜（a > b）

- **代码**
  ```c
  else { /* a > b */
     ms = j;         // 更新擂主
     j = ms + 1;     // 挑战者移到下一个位置
     k = *p = 1;     // 重置计数器和安全跳跃距离
  }
  ```

- **直观理解**
  - 当挑战者更强（a > b）时，挑战者成为新擂主。

- **为何一切"归零"？**
  - **p 重置为 1**：安全跳跃距离 p 是基于擂主 ms 计算的。新擂主出现后，旧的 p 失效，需要重新建立。
  - **k 重置为 1**：新擂主的首字符比较从零开始。
  - **j = ms + 1**：新擂主确定后，下一个挑战者从新擂主右侧第一个位置开始。

- **与情况1的区别**
  - 情况1（a < b）：擂主不变，j 向右移动，p 增大。
  - 情况3（a > b）：擂主更换，一切归零，p 重置为 1。

- **形象比喻**
  - 新擂主的出现意味着"历史清零"。之前的擂主赛历史、安全跳跃距离、失败者记录——全部作废。新擂主需要重新建立自己的"领地"。

### 3.8 双向最大后缀的预处理

#### 3.8.1 代码简述（C 代码片段 + 切分图）

```c
/* 预处理阶段：同时计算两个方向的最大后缀 */
i = maxSuf(x, m, &p);       /* 基于 <= 的最大后缀与安全跳跃距离 */
j = maxSufTilde(x, m, &q);  /* 基于 >= 的最大后缀与安全跳跃距离 */
if (i > j) {
   ell = i;
   per = p;
}
else {
   ell = j;
   per = q;
}
```

- `maxSuf` 在前文已完整展开；`maxSufTilde` 只是将比较方向从 `<=` 改为 `>=`，其余变量与控制流完全对称，因此在此不再重复代码细节。
- 这一段预处理的目标只有两个：
  - 在字典序升序与降序下，分别找到各自的最大后缀位置（潜在的临界分解点候选）；
  - 为每个候选位置给出一个局部安全跳跃距离（后续在搜索阶段经 `memcmp` 验证后，可能升级为真正的周期）。
- 通过 `ell = max(i, j)`，Two-Way 选择**更靠右**的那个最大后缀作为切分点，使得右半部 $R$ 尽量短、左半部 $L$ 尽量长，便于在搜索阶段先用短而“挑剔”的 $R$ 快速筛掉大量窗口。

- 预处理完成后的典型切分示意可以画成：

  ```
  模式串 P: [ * * * .. * * * * * .. * * * .. * ]   (* 为任意字符)
                          ^        ^
                          i        j
                                   ell = max(i, j)
          [          L            |    R  ]
  ```

- 这里 `i`、`j` 分别对应两个方向的最大后缀起点；`ell` 取其较大者，用来划分 `P = L | R`。  

#### 3.8.2 为什么取 $\max(i, j)$？


- **先处理最难对付的那半边**
  - 搜索阶段的核心思路可以表述为：如果右半部 $R$（最大后缀）都无法匹配，就没有必要再比较左半部 $L$。
  - 取更靠右的最大后缀作为切分点，效果是：
    - 切分点越靠右，左半部 $L$ 越长；一旦 $R$ 在某次对齐中失配，就可以直接放弃这一整段 $L$ 的比较，只依赖 $R$ 就结束当前尝试；
    - 让 $R$ 尽量短，每次对齐时先比较这几位，就能用很少的字符快速筛掉大量不可能的窗口；
    - 让 $L$ 尽量长，这段前缀一旦在某次完整匹配中被确认，搜索阶段可以配合 `memory` 变量在一段时间内"记住"它，避免重复比较（后文 [4.2.3 完整匹配、左半部回溯与 `memory`](#423-完整匹配左半部回溯与-memory) 小节会专门展开 `memory` 的作用，同时这也是搜索阶段从右向左移动的重要依据）。
  - `maxSuf (≤)` 倾向于捕捉“由大字符主导”的极值后缀，`maxSufTilde (≥)` 倾向于捕捉“由小字符主导”的极值后缀。  
  - 对两个结果取 $\max(i, j)$，本质上就是在这两类极值点中选择一个更靠右的切分位置，使得右半部 $R$ 足够短、足够靠近模式尾部，同时在该位置上算出的周期 `per` 既绝对安全又尽量短，便于在搜索阶段用尽可能少的比较完成一次对齐。

- **极端模式串上的 $\max(i, j)$ 行为**
  - 1) 单调递增与单调递减  
    - `P = "bbbbbba"`：单向最大后缀可能落在最左端，双向取 $\max$ 后切分为 `bbbbbb | a`，R 仅 1 字符。
    - `P = "aaaaaab"`：同理，双向取 $\max$ 后切分为 `aaaaaa | b`，R 仅 1 字符。
    - **说明**：单向检测时，极端单调串容易把切分点推向一端，使 R 变成整串；双向取 $\max$ 会把切分点推向右侧，使 R 恢复为很短的一段，加速筛选。
  - 2) 全相等串 `P = "aaaaaaa"`
    - 正向与反向最大后缀都得到 $ms = 0$，切分为 `(空) | aaaaaaa`，安全跳跃距离 $p = 1$。
    - **说明**：双向检测结果一致，说明串具有完全对称性。预处理只确认"安全位移 $p = 1$"，不预设周期；搜索时首字符失配即可排除，处理简单高效。
  - **模式总结**：
    - 极端递增/递减串：$\max(i, j)$ 把切分点推向右侧，R 保持极短，快速筛选；
    - 全相等串：$p = 1$，首字符失配即可排除，处理简单高效；
    - 一般串：靠右的 R 或较小的 p，至少有一项成立，确保线性复杂度。

- **双向最大后缀到底解决了什么问题**
  - 1) 数学背景：临界分解点（仅供参考）  
    - 数学文献里有一个经典理论：任何非空字符串都存在一些**临界分解点** $\ell$，在这些位置把串切成 $P = L \mid R$，可以用“局部重复结构”来刻画全局的重复规律。
    - Two-Way 的理论分析通常会借助这类定理来证明：总能选择某些“好用的分界点”，让基于它们计算出来的位移既安全又足够短。
    - 不过，这些证明给出的是一种“存在性保证”：它说明“有这样的好点”，并不意味着实现中每一次算出来的 `per` 都是**真正的全局最小周期**。
    - 在实际 C 实现里，`per` 从头到尾都被当成“安全跳跃距离候选”来用：
      - 预处理阶段根据最大后缀计算出一个“不会漏配”的位移；
      - 搜索阶段会通过`memcmp`来检验它：要么发现它在当前模式上可以当作周期使用，要么发现它只能当作保守位移，于是进入“非周期分支”。
    - 例如对于 `P = "abzyxzyxzyx"` 这样的串，靠右的候选切分点上能得到 `per = 3`：
      - 这在局部上看起来像一个周期，但并不能覆盖整串的结构；它的靠右切分点的`per`并不是很多讲解中靠右切分的`per`为全局最小周期。
      - 搜索阶段在检验后，会发现这个“周期”无法持续成立，从而走向非周期分支。
    - 正因为如此，在这篇笔记中更倾向于使用“安全跳跃距离”这个词，只在明确通过`memcmp(x, x + per, ell + 1)`验证之后，才把 `per` 视作“周期”来理解。

  - 2) 字典序的互补覆盖：为什么要看两个方向  
    - `maxSuf (≤)` 和 `maxSufTilde (≥)` 分别从两个相反的字典序方向去找各自的最大后缀。
      - 对接近单调递增的串，波峰会在右侧，正向最大后缀自然靠右；
      - 对接近单调递减的串，波谷会在右侧，反向最大后缀自然靠右。
    - 把两个方向都算一遍，并在它们之间取 $\max(i, j)$ 的效果可以概括为：
      - 不论“危险结构”是由大字符主导还是由小字符主导，总有一个方向会把它推到更靠右的位置；
      - 在这个更靠右的位置上计算出来的 `per`，至少不会“大到出问题”：它可能不是最短的，但不会跨过任何合法起点。
    - 只看其中一个方向时，某些模式串会让这个“最大后缀”偏到很左边，右半部 $R$ 变得很长，在这样的位置上算出来的安全跳跃距离 `per` 有可能过大，从而跨过真正的匹配起点。
    - 同时算出两个方向的结果，再在它们之间取 $\max(i, j)$，相当于：
      - 用两个方向互相“交叉检查”；
      - 选出一个更靠右、更安全的切分点，让这里的 `per` 至少不会因为过大而造成漏配。

  - 3) 抗退化性与 `memory` 的协同  
    - 从复杂度视角看，$\max(i, j)$ 做了两件事：
      - 用“极短的 $R$”保护每一次失败窗口：在待搜索文本串上的当前对齐窗口内，先比较少量、结构最复杂的字符，尽早判定“这一窗肯定不匹配”，从而跳过这一整次对齐；
      - 用“极长的 $L$”保护每一次成功对齐：一旦在某个对齐位置上确认了 $L$ 和 $R$ 都匹配，通过 `memory` 记录这一段已经验证过的前缀，在后续移动中只要仍然落在这段范围内，就可以不再重复比较这些字符。
    - 整体效果是：
      - 在预处理阶段，通过双向极值拿到一个"最不容易出错的切分点"和对应的安全跳跃距离候选 `per`；
      - 在搜索阶段，周期分支通过 `memory` 跳过已验证前缀，非周期分支通过安全上界保证不漏配。

    - 简单看一个 memory 抗退化的例子（周期串）：  
      - 模式串 `P = "ababab"`，周期 `per = 2`，切分点 `ell = 0`，`L = "a"`，`R = "babab"`。
      - 文本串 `T = "abababab..."`（连续重复）。
      - 第一次匹配（j = 0）：比较 R 成功，再比较 L 成功，输出匹配，`memory = m - per - 1 = 3`。
      - 第二次匹配（j = 2）：`i = MAX(ell, memory) + 1 = 4`，直接从位置 4 开始比较，跳过已验证的前 4 个字符。
      - 这就是 memory 的价值：在周期串上避免重复比较已验证区域，保证 O(n) 复杂度。
  - 4) 正确性的最后兜底  
    - 单向预处理只看一侧极值，可能给出“过大的候选位移 $per$”，在某些模式上会直接跨过真正的匹配起点，造成漏匹配。
    - 双向预处理的核心价值是**正确性保证**：
      - 先用两种字典序从两端夹出一个临界分解点；
      - 再在这个点上计算候选位移 `per`，并在搜索阶段用 `memcmp` 验证；
      - 只有在这两层保障都通过后，才能在对应的“周期分支”里，把 `per` 当作“全局周期 + 安全跳跃距离”来使用；“非周期分支”中，`per` 仍然只扮演一般的安全跳跃距离候选。
    - 这就是为什么，从“工程正确性”的角度看，取 $\max(i, j)$ 不是一个“漂亮的经验法则”，而是一条有数学兜底的硬约束。
#### 3.8.3 为什么必须双向检测？—— 单向策略一定会漏匹配

- Two-Way 的预处理看起来只是“多算了一次最大后缀”，但这一多算，实际上承担了正确性兜底的作用：只要我们**只看一个方向的最大后缀**，就总能构造出某些模式 / 文本对，使得搜索阶段漏掉合法匹配；而同时看两个方向并取 $\max(i, j)$，则可以在严格意义上排除这类漏配。

- 本节的目标可以概括为三点：
  - 先用具体例子说明：只用单向最大后缀，确实会在实际搜索中跨过合法起点（3.8.3.1）；
  - 再抽象这些反例背后的共同结构，给出“必须双向检测”的形式化证明（3.8.3.2）；
  - 最后回到 C 代码，从实现角度解释“单向漏匹配 ⇔ 某类 R 失配”，以及双向预处理如何在代码级别修复这一点（3.8.3.3）。

- 换成一句更程序员味的表述：
  - 任何“只依赖一个方向最大后缀”的搜索策略，**必然存在**某些模式 / 文本对会漏配；
  - Two-Way 的“双向最大后缀 + 取 $\max(i, j)$”则给出了一个简单、可实现、且有数学兜底的修复方案。

- **漏洞的根源：单向视角的偏见**
  - 最大后缀各看一侧：
    - `maxSuf (≤)` 寻找的是字典序最大的后缀（比如以 `'z'` 开头的后缀），它在预处理阶段给出的安全跳跃距离 $p_{≤}$，偏向捕捉**“由大字符主导的重复规律”**；
    - `maxSufTilde (≥)` 寻找的是字典序最小的后缀（比如以 `'a'` 开头的后缀），对应的 $p_{≥}$ 则偏向捕捉**“由小字符主导的重复规律”**。
  - 如果只看其中一侧，就等于只相信“高处”或“低处”的一种极值信息；当模式同时包含这两类结构时，单侧视角给出的位移可能过于乐观，从而在搜索阶段跨过真实起点。

- **对比示例：单向与双向预处理给出的直觉**
  - 正例（不会漏匹配）：  
    模式串 `P = "ba"`，文本串 `T = "ababa"`  
    - 只用 `maxSuf (≤)`：`ms = -1, p = 2`，仍能在 `T` 中找到所有匹配；  
    - 只用 `maxSufTilde (≥)`：`ms = 0, p = 1`，同样不会漏配，只是给出的安全跳跃距离更保守。

  - 反例（单向必漏）：  
    模式串 `P = "aaab"`，文本串 `T = "aaaab"`  
    - 只用 `maxSufTilde (≥)`：预处理得到 `ell = -1, p = 4`，搜索从 `j = 0` 一步跳到 `j = 4`，跨过了 `s = 1` 处的合法匹配；  
    - 若同时考虑另一方向的最大后缀并取 $\max(i, j)$，则可以避免这一类漏配（详细对齐过程见 3.8.3.1）。

  - **数学上的担保**
    取“字典序升序极值”和“降序极值”中更靠右的那个，等价于同时防住“波峰”和“波谷”两种结构，保证：  
    **p = 真正的最小安全跳跃距离**，而非某个方向的“局部安全位移”。
##### 3.8.3.1 反例扩展：单向最大后缀必漏匹配

- 下面继续给出两组模式 / 文本对，分别对应“只用 ≤”“只用 ≥”这两类单向策略。它们都满足：真实存在 `s = 1` 处的匹配，但单向 Two-Way 在对应方向上不会报告这个匹配。

- **反例 A（字母集 {a,b}，单向 ≤）**
  - 模式串 `P = "baaa"`，文本串 `T = "bbaaa"`，单向策略：仅用 `maxSuf (≤)`。
  - 实际上，在 `T` 中索引 `s = 1` 处存在一个完整匹配：
  - 只用 `maxSuf (≤)` 预处理：
    - `ell = -1, per = 4`（无内部周期，最大后缀视角把整个串当成一个块）；
    - 进入“非周期分支”，搜索从 `j = 0` 开始。

  - 逐字符对齐（按照 C 实现里 Two-Way 的“非周期分支”，从右半边 v 开始向右比较）：

    ```
    Index: 0 1 2 3 4
    T   :  b b a a a
    P   :  b a a a
             X
    失配点: i = 1 (P[1]='a', T[1]='b')
    位移 : j += i - ell = 1 - (-1) = 2
    ```

  - 此时 `j` 从 0 一步跳到 2，循环结束，`s = 1` 处的真实匹配被直接跨过。
  - 一句话总结：**单向 ≤ 在这种“左侧高峰 + 右侧平坦”的结构上，把最大后缀锁在过于靠左的位置（`ell = -1`），第一次失配就触发 `i - ell = 2` 的大步跳跃，从而越过中间的合法起点。**

- **反例 B（字母集 {a,b}，单向 ≥，落入“周期分支”）**
  - 模式串 `P = "aba"`，文本串 `T = "aaba"`，单向策略：只用 `maxSufTilde (≥)`。
  - `T` 中 `s = 1` 处同样有一个完整匹配：
  - 只用 `maxSufTilde (≥)` 预处理：
    - 可以算出 `ell = -1, per = 2`，同样满足 `memcmp(P, P + per, ell + 1) == 0`，于是落入 C 实现中的“周期分支”；
  - 周期分支下第一次比较与位移：

    ```
    j = 0, memory = -1
    i = MAX(ell, memory) + 1 = 0

    比较 P[0] 与 T[0]: 'a' == 'a' → i = 1
    比较 P[1] 与 T[1]: 'b' != 'a' → 在 v 处失配, i = 1

    j += i - ell = 1 - (-1) = 2
    ```

  - 此时 `j` 依然从 0 跳到 2，循环结束，`s = 1` 处的匹配同样被完全跳过。
  - 一句话总结：**单向 ≥ 只看“最小后缀”的低谷，同样可能把 `ell` 锁在过于靠左的位置，一旦在右侧失配，就会在周期分支里用 `i - ell` 一步跨过整个候选区间。**
##### 3.8.3.2 双向切分点为什么是"必须"的

> **初学者提示**：这一小节是算法正确性的严谨证明，如果你只是想理解算法如何工作，可以跳过这一节，直接读「四、TW 函数详解」。等你对算法有了整体理解后，再回来读证明会更容易。

- 这一小节要回答的问题只有一个：  
  - Two-Way 为什么一定要在两种字典序下都算一遍最大后缀，再取 `ell = max(ms_≤, ms_≥)`？  
  - 换句话说，`ell` 到底是“一个随便选的切分点”，还是“为了保证不漏配、不得不选出来的逻辑临界点”？  

- **从临界分解理论看双向性的数学依据（可略读）**
  - 这一小段给出一个高层直觉：为什么 Two-Way 会落到"算两个最大后缀再取 max"这种设计。真正严谨的不漏配证明仍然放在后面的"R失配分支的安全性反证"里完成。
  - 数学上有一个经典结论：任何非空字符串都存在**临界分解点**，在这些位置切分后，右半部 R 具有特殊的极值性质，可以保证 R 失配时的跳跃 `i - ell` 是安全的。
  - 问题在于：如何找到这个临界分解点？
    - 单向最大后缀只能捕捉一个方向的极值性质（"波峰"或"波谷"之一）；
    - 某些模式串上，单向会给出过于靠左的切分点，导致 R 失配时的跳跃 `i - ell` 过大，跨过真实匹配起点。
  - 双向最大后缀的解决方案：
    - 分别在两种字典序下求出最大后缀起点 `ms_≤` 和 `ms_≥`；
    - 取 `ell = max(ms_≤, ms_≥)`，选择更靠右的切分点；
    - 这样 R 更短，R 失配时的跳跃 `i - ell` 更保守，同时极值性质保证了安全性。

- **R失配分支的安全性反证：为什么必须是双向切分**
  - 证明思路可以概括为两步：
    1. 从单向漏配的实例出发，可以观察到两点：  
       - 失配发生在 R 区域；  
       - 在下一步对齐中，模式串左半部 `L` ，整体落入了右半部 `R` 在文本上的镜像区。  
       因此第一步要做的，就是在 C 代码层面证明：**如果真的发生漏配，那次失配必定是一次 R 失配**，并且对应着“某种形式的 L 落入镜像区”，从而把分析范围收缩到这一条分支上。
    2. 在“漏配 + R 失配”的前提下，唯一可能把真实起点跨过去的更新语句就是 `j += i - ell`：  
       - 假设确实存在一个真实匹配起点 `s`，满足 `j < s < j + (i - ell)`，记 `d = s - j`，则有 `0 < d < i - ell`；  
       - 接下来整节的推导，就围绕这个假想的短跳 `d` 展开：一方面借助镜像区，探索模式串内部`L`和`R`的几何关系，另一方面在这两种几何下分别套用正向 / 反向最大后缀的性质，看看单向信息能否排除所有这样的 `d`，从而得出双向检测的必要性。
    3. 额外说明: `ms_≤ == ms_≥` 的情况只出现在 `"aaaaaa"` 这种全等字符串情形中，但该情况较为简单，故不再赘述。

- **步骤 1：把问题收缩到 R 失配分支**
  - **定义（R 失配事件）**
    - 对齐 `P[0..m-1]` 与 `T[s..s+m-1]`，若最右侧失配点为 `P[k]` 且 `k > ell`，称为一次 **R 失配**。

  - **引理（单向漏匹配 ⇒ 必为 R 失配后右移重对齐）**
    - 若单向最大后缀导致漏匹配，则该次失配必为一次 R 失配，且位移 `j += i - ell` 的新对齐位置严格落在正确起点 `s` 之后，从而越过 `s`。

  - **证明**
    - 分几步分析 C 代码中的所有失配路径：
      1) 失配只可能出现在两处  
         - 右半部比较阶段：从左向右比较，`i < m` 时`x[i] != y[i + j]`，退出`while`循环，触发 `j += i - ell`；  
         - 左半部比较阶段：右半部完全匹配后，从 `i = ell` 向左比较。  
      2) 左半部失配的位移完全由预处理阶段算出的安全跳跃距离 `p` 决定（在 `TW` 函数中通过选择 `p` 或 `q` 赋值给 `per`）  
         在两条分支中，左半失配或完全匹配后的更新都是：
         - 周期分支：`j += per`；  
         - 非周期分支：`per = MAX(ell + 1, m - ell - 1) + 1`，然后同样 `j += per`。（安全上界的完整证明见[4.3.2 安全上界的几何推导](#432-安全上界的几何推导)）
         这里的位移不依赖失配索引 `i`，而是由 `per` 给出的“安全跳跃上界”：  
         - 任何 `j < t < j + per` 的起点 `t` 都会与当前窗口的某一部分发生必然冲突，因此这些窗口已经在当前对齐中被排除（这点在 3.5.1 中已经通过“镜像区 + 守尾字符”的方式详细证明过，这里只做结论性引用）；  
         - 换句话说，左半部比较阶段不会产生“跳过尚未验证窗口”的过度跳跃。  
      3) 因此，漏匹配只能通过右半部失配发生  
         唯一可能跨越尚未验证窗口的更新语句是 `j += i - ell`，而它只在右半部比较失败时触发，此时失配索引满足 `i >= ell + 1`。  
         若存在一次漏匹配，即某个真实起点 `s` 没有被检查却被某次跳跃跨过，则这次跳跃必由 `j += i - ell` 产生，因此对应的一定是一次 R 失配。  
      4) 右移重对齐  
         设这一跳前窗口起点为 `j`，真实匹配起点为 `s`，跳后为 `j' = j + i - ell`。  
         我们就把“这一步跳过了真实起点”定义为存在  
         `j < s < j'`，也就是：  
         ```
         0 < s - j < j' - j = i - ell
         ```  
         上面只是把“`j < s < j'`”换成完全等价的不等式写法，没有多做任何推理。  
         对于满足 `j < s < j'` 的那一步跳跃来说，Two-Way 在此之后只会继续向右移动窗口，`j` 只会从 `j'` 往右增加，不会再回到 `s`；换句话说，这次跳跃把真实起点 `s` 永久留在了左侧。  
         结合前面“左半部比较不会产生过度跳跃”的结论，单向漏匹配只可能出现在这种由 R 失配触发的 `j += i - ell` 上。

- **几何图解：R 失配与镜像区**
  - 从对齐图的角度看，R 失配 + `j += i - ell` 做的事情，可以形象地理解为：
  - 1) 先看一次典型的 R 失配位移

    ```
    P = L R = abc|yx
    T 当前窗口:
         j             
    T :  a  b  c  y  z  ...
    P :  a  b  c  y  x
                     ↑
                在 i=4 处发生 R 失配 (P[4]='x', T[j+4]='z')

    ell = 2 (L = abc, R 从下标 3 开始)
    位移: j' = j + i - ell = j + 4 - 2 = j + 2

    新对齐:
           j       j'          j'+ell+1
    T :    a   b   c   y   z  ...
    P :            a   b   c   y   x
                           ↑   ↑
                           L尾 R首
    ```

    - 可以看到：
      - 在这一步 R 比较中，算法先在 `R` 的首字符上读到一个匹配的 `y`，然后在下一位上遇到失配字符 `z`：本轮访问的 T 字符都落在旧窗口中 `R` 覆盖的那一小段里，且已经匹配过的只有“镜像区”里的那一个 `y` 再加上一个新的失配字符；  
      - 旧失配点（字符 `z` 所在的位置）在新对齐中位于 `L` 的尾字符 `c` 的正上方，而 `R` 的首字符 `y` 则落在它的右边一格。

    - 注意，与朴素的想法不同，`j += i - ell` 并不是用 `R` 的首字符去比较旧失配点，而是比较旧失配点的下一字符，同时整个 `L` 向右平移，让 `L` 的某一段落入 `R` 的“镜像区”中。

  - 2) R 失配下的短跳与双向切分点
    - 前文已将问题收缩到“漏配 + R 失配 + 短跳 `0 < d < i - ell`” 的框架下，本小节就在这个场景里做一次反证：  
      - 先假设存在某个位移 `d`，既满足 `0 < d < i - ell`、又能在真实起点 `s` 处找到一次完整匹配；  
      - 再结合几何关系和最大后缀的性质，逐步检查这个假设能否自洽；  
      - 如果推导过程中发现，单侧最大后缀总会在某一类几何下放走某些 `d`，而只有同时使用左右两侧的最大后缀才能把所有 `0 < d < i - ell` 排除干净，那就说明切分点 `ell` 必须由双向检测共同确定，`j += i - ell` 的安全性也就反过来成为这种“双向性”的结果。

  - 场景与记号约定:
    - 预处理阶段在两种字典序下分别求出最大后缀起点 `ms_≤, ms_≥`，取 `ell = max(ms_≤, ms_≥)` 作为切分点，把模式串写成 `P = L R`；此时较右的那个极值落在 `R` 的开头，另一个极值则必然位于 `L` 的内部；  
    - 当前文本窗口从 `j` 开始，处在 `R` 比较阶段；  
    - 在某个位置 `i > ell` 首次失配：`P[i]` 与 `T[j+i]` 不等，记 `t_mis = T[j+i]`；  
    - 在此之前，`P[ell+1..i-1]` 与 `T[j+ell+1..j+i-1]` 完全相等，这一段记作镜像区 `M`。

  - 在上述记号下，Two-Way 对这次 R 失配给出的位移是

    `j' = j + (i - ell)`

  - 从对齐图上看，这一步等价于：把 `L` 的尾字符平移到失配字符 `t_mis` 的位置。接下来要做的，就是检查：有没有可能存在一个更短的位移，同样能在某个起点对齐出完整匹配，却被这一跳跨过去。

  - 为此作如下假设：
    - 存在某个真实匹配起点 `s`，满足 `j < s < j'`；  
    - 令 `d = s - j`，则 `0 < d < i - ell`，也就是我们尝试用更短的位移 `d` 去对齐 `P`；  
    - 由于 `d < i - ell`，以 `s` 为起点时，整段 `L` 都落在 `t_mis` 的左侧，`t_mis` 一定对齐到 `R` 内部某个位置，而不会再被 `L` 覆盖。

  - 在这个假设下，`L` 落入镜像区只能有两种几何位置关系。

  - 1) **L 的某个后缀覆盖了 R 的某个前缀**

    ```
    P = L R

    before shift (R mismatch at position i):
          j             j+i
    T :      .. [   M  t_mis] ...
    P :   [L   ][  M  P[i]  ]
                        ^
                        mismatch

    after shift by full distance (i - ell):
            j'           j'+|L|
    T :  ... [  M   t_mis] ...
    P :  [   |     L     ][  R    ]
             |-----^-----|      
                   L_suffix
    ```

  - 按照 `j' = j + (i - ell)` 跳时，`L` 的尾字符会刚好压在 `t_mis` 上；任何真正的匹配起点 `s` 都满足 `j < s < j'`，也就是 `d = s - j < i - ell`，所以在以 `s` 为起点的那次对齐中，整段 `L` 都不会覆盖到位置 `j+i`：`L` 和这次失配字符完全脱离接触。

  - 另一方面，镜像区 `M` 本身就是 `R` 的一个非空前缀。如果此时 `L` 较长，只让它的某个后缀落在 `M` 上，就得到一个等式：

    ```
    L_suffix = R_prefix
    ```

  - 其中 `R_prefix` 是 `R` 的某个非空前缀，`L_suffix` 是 `L` 的某个后缀。把 `L` 和 `R` 拆成
    - `L = L_prefix · L_suffix`  
    - `R = R_prefix · R_suffix`

  - 代入 `P = L R`，得到

    ```
    P = L_prefix · L_suffix · R_prefix · R_suffix
      = L_prefix · R_prefix · R_prefix · R_suffix
    ```

  - 也就是说，在模式串内部出现了这样一条后缀：

    ```
    R_prefix · R_prefix · R_suffix
    ```

  - 它和当前的 `R = R_prefix · R_suffix` 以同一个前缀开头，但前者更长。在选定的字典序方向上，前者严格压过后者，这与预处理阶段“`R` 是字典序最大后缀”的结论矛盾。  
  - 整个推理完全建立在“**单向**最大后缀”的性质之上：并没有用到 `L` 内部是否包含反向最大后缀的信息，所以即便只有一侧的最大后缀，仍然可以排除这种几何对应的漏配。  
  - 也正因为如此，这一节只能说明：单向逻辑在某一类几何上“够用”，却无法保证所有更短的位移都被排除掉。要想补上这个空档，就必须在下一种情形中把 `L` 的反向最大后缀也拉进来一起约束。

  - 2) **L 完全落在某个 R 前缀内部（L 是 R 的一段中缀）**
    - 这一类几何对应的是“L 比较短、镜像区把它整段包住”的情形。把前后两次对齐放在一条线上会更清楚：

    ```
    before shift:
    T : ... |   L   |      M      | t_mis | R_suffix | ...
    P :     |   L   |      M      |  P[i] | R_suffix |
                                     ^
                                     mismatch (t_mis != P[i])

    after shift by d (0 < d < i - ell):
    T : ... |   L   |   M         | t_mis | R_suffix | ...
    P :                |  L  | R2 | P[i-d] | ...
                   |=============|
                     mirror zone
    ```
    - 镜像区保证：标出的那段 `L · R2` 与跳跃前的 `M`（mirror zone）在失配点左侧完全相等；  
    - 又因为我们假设“短跳 `d` 之后可以成功匹配，那么对于位置 `i`”，有 `t_mis = T[j+i] == P[i-d]`，而一开始 `t_mis != P[i]`，于是得到

    ```
    P[i] != P[i-d]
    ```

    - 在这块公共的 `L · R2` 上，可以抽出一个紧挨着失配位置的非空子串，记作 `Q`。现在从“跳跃前 / 跳跃后”的分解关系来约定谁是前缀、谁是后缀：
      - 若选择双向检测最大后缀，并选择靠右的最大后缀作为切分点，那么 `R` 为靠右侧的最大后缀，而 `L` 中应包含反序最大后缀的起点。
        - `L` 中包含反序最大后缀的起点，不妨将它设为`L`的首字符，这并不会影响分析的正确性。
      - 跳跃前
        - 由镜像区的相等传导，可在 `M` 中找到 `R2` 的相等映射，经过代换， `R2 · P[i]` 可视为跳跃前模式串 `R`的某个后缀。
        - 由镜像区的相等传导，可在 `M` 中找到 `Q` 的相等映射，经过代换， `Q · P[i]` 可视为跳跃前模式串反序最大后缀的某个后缀。
      - 跳跃后
        - `R2 · P[i-d]` 可视为跳跃后模式串 `R`的前缀。
        - `Q · P[i-d]` 可视为跳跃后模式串反序最大后缀。 

    - 接下来在讨论最大后缀性质时，只需要在这个 Q 之后再各自接上失配处的那个字符（如 `P[i]` 或 `P[i-d]`），就可以把两次比较都规约到“公共前缀 + 不同末尾字符”的形式上。

    - 因此：
      - 利用“`R2 · P[i-d]` 是正向最大后缀”，在正向字典序下比较 `R2 · P[i]` 与 `R2 · P[i-d]`，可得`R2 · P[i-d] >= R2 · P[i]` ，且又有 `P[i-d] != P[i]`，故`P[i-d] > P[i]`。
      - 利用“`Q · P[i-d]` 是反向最大后缀”，在反向字典序下比较 `Q · P[i]` 与 `Q · P[i-d]`，可得`Q · P[i-d] <= Q · P[i]`（注意这里是反序），且又有 `P[i-d] != P[i]`，故`P[i-d] < P[i]`。

    - 两边叠加，就是在同一对字符 `P[i]` 和 `P[i-d]` 上，同时要求它“既大于又小于”对方，这显然不可能。  
      因此在 “L 完全落在 R 前缀内部” 的情形下，也不存在这样一个短跳 `0 < d < i - ell` 能够通过所有比较。这里与前一种情形最大的不同在于：推导真正用上了“`L` 是反向最大后缀”的约束——如果没有这层约束，关于 `P[i]` 和 `P[i-d]` 的那对相反不等式就建立不起来，理论上确实可能存在某个漏掉的 `s`。换句话说，正向最大后缀负责从右侧堵住一部分危险跳跃，反向最大后缀则从左侧补齐剩下的缺口，两者共同把所有 `0 < d < i - ell` 排除在外。

- 综上，只要 `ell` 真的是由“两种字典序下的最大后缀”共同确定出来的靠右那个切分点，上面这两种“L 落入镜像区、且存在短跳 `0 < d < i - ell` 能把窗口起点从 j 移到 s 的起点” 的几何形状就不可能出现；换句话说，在 R 失配分支里，如果真实起点 s 存在，它不可能夹在 j 和 j' = j + i - ell 之间，所有这些仅用于反证的短跳 d 都会被正向 / 反向最大后缀的约束排除掉，算法真正实际采用的位移只有 `j += i - ell`。  

- 到这里，可以把本节一开始的问题串起来看：
  - 只用单向最大后缀时，前面的反例已经表明：有可能选错切分点 `ell`，从而真的出现“更短跳跃导致漏配”的模式串；  
  - 本节的反证从头到尾都依赖于两个极值假设：
    - 右侧 `R` 是正向字典序下的最大后缀；  
    - 左侧 `L` 是反向字典序下的最大后缀。

- 也就是说，我们之所以能证明“`i - ell` 是唯一安全的跳跃距离”，前提正是：`ell` 同时受这两个最大后缀的约束。一旦少掉任意一边，上面用来制造矛盾的那对不等式就失效了，更短的跳跃不再被逻辑排除，单侧检测的反例也就顺理成章地出现。

- 这正是“双向检测必要性”的数学表达：  
  - 算法要想既保证 `j += i - ell` 是安全上界，又排除所有更短的危险跳跃，就必须同时维护正向和反向两个最大后缀；  
  - Two-Way 取 `ell = max(ms_≤, ms_≥)`，恰好把这两个极值“拧”在同一个切分点上，使得搜索阶段的每一次 R 失配，都站在这套双向约束之上。
  
## 四、TW 函数详解

### 4.1 周期性的判断（memcmp(x, x + per, ell + 1)）

- 预处理阶段结束后，TW 函数在进入搜索主循环之前，执行了一行看似简单的判断：

```c
if (memcmp(x, x + per, ell + 1) == 0) {
    /* 进入"周期分支" */
} else {
    /* 进入"非周期分支" */
}
```

- 这行代码比较了长度为 `ell + 1` 的两个子串：`x[0..ell]` 与 `x[per..per+ell]`。若两者相等，TW 进入周期分支；否则进入非周期分支。
- 本节的核心问题是：**这行判断究竟在验证什么？为什么它能决定后续搜索策略的分野？**

#### 4.1.1 per 的双重身份：安全跳跃距离与周期候选

- 在预处理阶段，`maxSuf / maxSufTilde` 除了给出切分点 `ell` 外，还会输出一个整数 `per`。第三章的分析表明，这个 `per` 具有"安全跳跃距离"的性质：
  - 对于任意更小的位移 `1 ≤ d < per`，若将右半部 `R = x[ell+1..m-1]` 向右平移 `d` 位，必然会在重叠区域产生字符冲突。
  - 换句话说，`per` 是"最小不会立刻产生冲突的平移步长"。

- 正如 [3.5.5 小节](#355-安全跳跃距离与周期的关系) 所论述，"安全跳跃距离"与"最小周期"是等价概念。对于后缀 `R`，`per` 既是它的最小安全跳跃距离，也是它的最小周期——即对于 `ell+1 ≤ i, i+per < m` 的所有位置，都有 `x[i] = x[i+per]`。

- 但这里有一个关键限制：**这只是右半部内部的局部结论**。第三章的证明只保证 `per` 在 `R` 的视野里是安全的，并不能直接说明整个模式串在步长 `per` 下是"全局平移安全"的。

#### 4.1.2 memcmp 的桥梁作用

- 要把 `per` 从"右半部的安全步长"升级为"整串的全局周期"，需要额外验证：左半部 `L = x[0..ell]` 在平移 `per` 步后是否也能保持一致。
- 这正是 `memcmp(x, x + per, ell + 1)` 的作用：
  - 若返回 0，表示 `x[0..ell] == x[per..per+ell]`，即对所有 `0 ≤ i ≤ ell` 都有 `x[i] = x[i+per]`（前提是 `i+per < m`）。
  - 这一比较完成了一个关键的"桥接"：把左半部的每个字符与其平移 `per` 后的位置关联起来。

- 把预处理阶段和 `memcmp` 的结果拼在一起，就得到完整的全局平移自洽性：
  - 在右半部内部，`per` 作为最小安全跳跃距离，保证了所有 `ell+1 ≤ i, i+per < m` 的位置满足 `x[i] = x[i+per]`。
  - 通过 `memcmp`，额外保证了所有 `0 ≤ i ≤ ell` 且 `i+per < m` 的位置也满足 `x[i] = x[i+per]`。
  - 综合起来：凡是下标 `i, i+per` 都落在 `x[0..m-1]` 范围内的位置，一律有 `x[i] = x[i+per]`。

#### 4.1.3 一个困惑：中间的"Gap"怎么办？

- 在实际例子中，`ell` 与 `per` 的大小关系可能产生一些看似"中空"的区域。例如：
  - 模式串 `x = "abcdabcdabcd"`，假设 `ell = 2`（切分为 `"abc" | "dabcdabcd"`），`per = 4`。
  - `memcmp` 比较的是 `x[0..2]` 与 `x[4..6]`，即 `"abc"` 与 `"abc"`。
  - 此时 `x[3] = 'd'` 既不属于被比较的左半部前缀，也不属于右半部平移后的对应区域。

- 初看之下，一个自然的困惑是：**这些没有被直接比对过的字符，会不会在右移 `per` 步之后参与重叠，从而破坏所谓的周期性？**

- 答案是否定的。原因在于：**真正危险的是"重叠区里的冲突"，而不是"中间有没有一块没人管的 Gap"**。

- 让我们仔细分析平移 `per` 步后可能产生重叠的所有位置：
  - 对于任意位置 `i`，如果 `i + per < m`，那么平移后 `x[i]` 会与 `x[i+per]` 产生关联。
  - 这个 `i` 要么落在左半部 `L = x[0..ell]`，要么落在右半部 `R = x[ell+1..m-1]`。
  - 若 `i` 落在 `L` 中：`memcmp` 已经验证了 `x[i] = x[i+per]`。
  - 若 `i` 落在 `R` 中：`maxSuf` 的性质保证了 `x[i] = x[i+per]`（因为 `per` 是 `R` 的最小周期）。

- 那 Gap 里的字符呢？以 `x[3] = 'd'` 为例：
  - 当 `i = 3` 时，`i + per = 7`，仍在模式串内，所以 `x[3]` 确实会与 `x[7]` 产生关联。
  - 但 `i = 3` 落在 `ell+1 = 3` 的边界上，属于右半部 `R` 的起始位置！
  - 因此 `x[3]` 与 `x[7]` 的相等关系已经由 `maxSuf` 的周期性质保证。

- 更一般地，所谓"Gap"实际上只是 `L` 和 `R` 之间的边界区域。任何在平移 `per` 步后仍留在模式串内的字符，必然属于以下两种情况之一：
  - 属于 `L`：由 `memcmp` 覆盖。
  - 属于 `R`：由 `maxSuf` 的周期性质覆盖。

- 换句话说，`memcmp` 和 `maxSuf` 的组合已经"封死"了所有可能产生重叠冲突的位置。Gap 里的字符即使看起来"没人管"，它们在平移后要么被甩到模式串之外（不参与下一轮对齐），要么已经被上述两种机制之一覆盖。

#### 4.1.4 per 的最终含义：从局部安全到全局周期

- 综合以上分析，可以给 `per` 一个完整的定义：
  - **在临界切分点 `ell` 处，`per` 是"最小平移自洽单位"**：
    - 在右半部视野下，比 `per` 更短的任何平移都会立刻导致冲突。
    - 在整串视野下，步长恰为 `per` 的所有重叠区，其字符都已由 `maxSuf + memcmp` 验证为相等。
  - **从搜索阶段的角度，它是一个"全局平移安全步长"**：
    - 若右移少于 `per` 步，必定在重叠区产生冲突。
    - 若恰好右移 `per` 步，所有重叠区都已验证匹配，不会漏掉任何可能的匹配起点。

- 正因为如此，一旦 `memcmp(x, x + per, ell + 1) == 0` 成立，TW 就有足够的理由进入"周期分支"，放心地：
  - 把右半部看作拥有周期 `per` 的后缀。
  - 把整串在步长 `per` 下看作"无冲突的平移序列"。
  - 在匹配成功或左半部失配时，用 `j += per` 和 `memory` 来复用已经确认过的比较结果。

- 反之，如果 `memcmp` 失败，就意味着：
  - 右半部虽然在 `per` 下自洽，但前缀在同样的平移下会与右半部产生矛盾。
  - 此时只能承认：真正的全局平移单位比当前的 `per` 更大，于是转入"非周期分支"，用显式的上界公式

```c
per = MAX(ell + 1, m - ell - 1) + 1;
```

  - 来给出一个始终安全、但可能偏保守的跳跃步长。

### 4.2 周期性搜索分支

- 当 `memcmp(x, x + per, ell + 1) == 0` 成立时，TW 进入周期分支。此时 `per` 已被验证为全局安全步长，搜索阶段可以充分利用这一周期性质来优化比较过程。
- 本节从几何位移的视角，拆解周期分支的执行逻辑。

#### 4.2.1 算法骨架与执行流程

- 周期分支的核心代码如下：

```c
if (memcmp(x, x + per, ell + 1) == 0) {
    j = 0;
    memory = -1;
    while (j <= n - m) {
        i = MAX(ell, memory) + 1;
        while (i < m && x[i] == y[i + j])
            ++i;
        if (i >= m) {
            i = ell;
            while (i > memory && x[i] == y[i + j])
                --i;
            if (i <= memory)
                OUTPUT(j);
            j += per;
            memory = m - per - 1;
        }
        else {
            j += (i - ell);
            memory = -1;
        }
    }
}
```

- 每一轮窗口扫描可分解为三个阶段：
  - **阶段1：确定起点**
    - `i = MAX(ell, memory) + 1`
    - 初次扫描：`memory = -1` → `i = ell + 1`（右半部首字符）
    - 后续扫描：`memory > -1` → 跳过已验证前缀
  - **阶段2：右半部向右比较**
    - `while (i < m && x[i] == y[i + j]) ++i`
    - 失配于 `i < m` → R 失配分支
    - 匹配至 `i >= m` → 完整匹配分支
  - **阶段3：位移决策**
    - R 失配：`j += (i - ell), memory = -1`
    - 完整匹配：`j += per, memory = m - per - 1`

#### 4.2.2 R 失配：临界位移的几何意义

- 当右半部比较在某个 `i < m` 处失配时，执行：

```c
j += (i - ell);
memory = -1;
```

- **几何位移图解**：

```
模式串 P = L | R, 切分点 ell = 2, R = "yx"

失配前的对齐状态:
         j             j+i
T :  ... a   b   c   y   z   ...    (文本串)
P :      a   b   c   y   x          (模式串)
         |---L---|   |R  |
                     ↑
              在 i=4 处失配 (P[4]='x' ≠ T[j+4]='z')
              
              已匹配的镜像区 M = "y"

位移计算: j' = j + (i - ell) = j + (4 - 2) = j + 2

失配后的新对齐:
             j'         j'+ell+1
T :  ... a   b   c   y   z   ...
P :          a   b   c   y   x
             |---L-------|  |R|
                         ↑
               L 的尾字符压在失配点 z 上
```

- **为什么是 `i - ell`？**
  - 在 [3.8.3 小节](#383-为什么必须双向检测--单向策略一定会漏匹配)中已证明：当切分点 `ell` 由双向最大后缀共同确定时，对于任意 R 失配位置 `i`，唯一安全的位移就是 `i - ell`。
  - 任何更短的位移 `0 < d < i - ell` 都会在镜像区内制造与极值性质矛盾的局部结构，从而被排除。

- **为什么重置 `memory = -1`？**
  - R 失配意味着当前窗口的右半部已出现冲突。
  - 上一轮匹配中的记忆不再可靠，必须重新从 `ell + 1` 开始比较。

#### 4.2.3 完整匹配与 L 失配：周期复用的几何意义

- 当右半部比较一路成功到 `i >= m` 时，进入左半部比较：

```c
i = ell;
while (i > memory && x[i] == y[i + j])
    --i;
if (i <= memory)
    OUTPUT(j);
j += per;
memory = m - per - 1;
```

- 无论 L 全匹配还是 L 失配，位移都是 `j += per`，memory 都设为 `m - per - 1`。
- 关键观察：
  - `memory = m - per - 1 >= ell` 总是成立（因为 `per` 是 R 的最小周期，`per <= |R| = m - ell - 1`）。
  - `len(L) = ell + 1 < per` 总是成立（如果 `len(L) >= per`，最大后缀会落在 L 内部，切分点就不是 `ell` 了）。

- **情况一：上一轮 L 全匹配 → 开启下一轮**

  - **memory 对 R 比较的作用**：
    - 下一轮 R 比较从 `i = MAX(ell, memory) + 1 = memory + 1` 开始（因为 `memory >= ell`）。
    - 跳过前 `memory + 1` 个字符，这些字符在上一轮 R 匹配中已验证。
    - 例子：`P = "ababab"`，`ell = 0`，`per = 2`，`memory = 3`。
      - 上一轮 R 全匹配（`"babab"`），L 全匹配（`"a"`）。
      - 下一轮 `i = MAX(0, 3) + 1 = 4`，直接从位置 4 开始比较。
      - 位置 0-3（`"abab"`）在上一轮 R 匹配中已验证，跳过。

  - **memory 对 L 比较的作用**：
    - L 比较的条件是 `while (i > memory && x[i] == y[i + j])`。
    - 由于 `memory >= ell`，条件 `ell > memory` 为假，L 完全不比较，直接输出匹配！
    - 例子：`P = "ababab"`，`ell = 0`，`memory = 3`。
      - `i = ell = 0`，条件 `0 > 3` 为假，`i <= memory` 成立，直接输出匹配。
      - 原因：整个模式串都是周期的，L 区域（位置 0）已被 memory 覆盖。

- **情况二：上一轮 L 失配 → 开启下一轮**

  - **memory 对 R 比较的作用**：
    - 上一轮 L 失配意味着 L 区域有冲突，但 R 全匹配。
    - 下一轮 `memory = m - per - 1` 来自上一轮 R 匹配的信息。
    - 由于 `memory >= ell`，R 比较仍从 `memory + 1` 开始，跳过已验证的前缀。
    - 例子：`P = "abcabc"`，`ell = 0`，`per = 3`，`memory = 2`。
      - 上一轮 R 全匹配（`"bcabc"`），L 失配（`"a"` 不匹配）。
      - 下一轮 `i = MAX(0, 2) + 1 = 3`，从位置 3 开始比较。
      - 位置 0-2（`"abc"`）在上一轮 R 匹配中已验证，跳过。

  - **memory 对 L 比较的作用**：
    - L 比较条件 `ell > memory` 仍为假，L 不比较。
    - 几何意义：位移 `per` 后，原来的 L 区域已移动到 R 区域内部，完全被 memory 覆盖。
    - 反例思考：`P = "abcdeab"` 是否能进入周期分支享受 memory 优化？
      - 这个模式串初眼看去：右移 5 步后，`"ab"`（位置 0-1）与 `"ab"`（位置 5-6）对齐。
      - 如果能进入周期分支，位移后 L 从右向左比较：先比 'd'，再比 'c'，然后通过 memory 发现 `"ab"` 无需比较。
      - 但 `maxSuf` 给出的 `per = 3`，不是全局周期 5，`memcmp` 检查失败。
      - 结论：这个模式串因 `memcmp` 失败进入非周期分支，无法享受 memory 优化。

- **`memory = m - per - 1` 的几何含义**：
  - 重叠区长度为 `m - per`，其最后一个下标为 `m - per - 1`。
  - `memory` 记录这个下标，表示"从 0 到 memory 的前缀已验证"。
  - 由于 `memory >= ell`，后续轮的 L 比较总是被跳过，只有第一轮（`memory = -1`）会执行 L 比较。

- **为什么 R 失配后 memory 置为 -1？**
  - memory 记录的"已验证前缀"全部来自 R 匹配的结果。
  - R 失配意味着这些验证信息已失效，必须重置为 -1，从头开始比较。

- **周期复用的效率**：
  - 无 memory 优化时：每轮都比较整个模式串，复杂度 O(m)。
  - 有 memory 优化时：第一轮比较 m 个字符；后续轮跳过已验证的前缀，仅比较 per 个字符。
  - 总比较次数：O(n) 而非 O(nm)。

#### 4.2.4 两种位移的对比

- 周期分支使用两种不同的位移策略：

| 场景 | 位移公式 | 几何意义 | memory 状态 |
|------|----------|----------|-------------|
| R 失配 | `j += (i - ell)` | L 尾字符压在失配点 | 重置为 -1 |
| L 失配 | `j += per` | 周期平移，复用重叠区 | 设为 `m - per - 1` |
| 完整匹配 | `j += per` | 周期平移，复用重叠区 | 设为 `m - per - 1` |

- **位移大小的几何对比**：

```
情况1: R 失配时的位移 (i - ell)

T :  ... X   X   X   Y   Z   ...    (Z 为失配字符)
P :      L   L   L   R   R
                     ↑
              失配点 i
              
位移 = i - ell (让 L 的尾部对齐失配点)

情况2: 完整匹配时的位移 per

T :  ... A   B   C   A   B   C   A   B   C   ...
P :      A   B   C   A   B   C
         |-------|-------|
         
位移 = per (周期平移，重叠区可复用)

关键区别:
- (i - ell): 取决于失配位置，可能大于或小于 per
- per: 固定周期，保证重叠区可复用
```

#### 4.2.5 小结：周期分支的核心思想

- 周期分支的前提是 `memcmp` 验证 `per` 为全局安全步长。
- **R 失配路径**：位移 `j += (i - ell)`，由双向最大后缀约束保证安全性，大步跳过不可能匹配区域。
- **完整匹配路径**：位移 `j += per`，由周期性质保证重叠区可复用，利用 memory 跳过已验证前缀，将重复比较压至常数级别。
- **复杂度保证**：O(n)，每个文本位置最多被比较常数次，memory 机制确保同一位置不重复参与左半部回溯。

### 4.3 非周期性搜索分支

- 当 `memcmp(x, x + per, ell + 1) != 0` 时，TW 进入非周期分支。这意味着 `per` 无法升级为全局安全步长，模式串缺乏足够强的周期性来支持 memory 优化。
- 本节从几何位移的视角，拆解非周期分支的执行逻辑。

#### 4.3.1 算法骨架与执行流程

- 非周期分支的核心代码如下：

```c
else {
    per = MAX(ell + 1, m - ell - 1) + 1;
    j = 0;
    while (j <= n - m) {
        i = ell + 1;
        while (i < m && x[i] == y[i + j])
            ++i;
        if (i >= m) {
            i = ell;
            while (i >= 0 && x[i] == y[i + j])
                --i;
            if (i < 0)
                OUTPUT(j);
            j += per;
        }
        else
            j += (i - ell);
    }
}
```

- 与周期分支对比，非周期分支的关键差异：

| 特性 | 周期分支 | 非周期分支 |
|------|----------|------------|
| memory 变量 | 有，记录已验证前缀 | 无 |
| 右半部起点 | MAX(ell, memory) + 1 | 固定 ell + 1 |
| 成功后位移 | j += per（精确周期） | j += per（安全上界） |
| R 失配位移 | j += (i - ell) | j += (i - ell) |
| 左半部回溯 | 截止于 memory | 截止于 0 |

- 每一轮窗口扫描可分解为三个阶段：
  - **阶段1：右半部比较**
    - `i = ell + 1`
    - `while (i < m && x[i] == y[i + j]) ++i`
    - 失配于 `i < m` → R 失配分支
    - 匹配至 `i >= m` → 进入左半部回溯
  - **阶段2：左半部回溯**
    - `i = ell`
    - `while (i >= 0 && x[i] == y[i + j]) --i`
    - `i < 0` → 完整匹配，OUTPUT(j)
    - `i >= 0` → 左半部失配
  - **阶段3：位移决策**
    - R 失配：`j += (i - ell)`
    - 成功/左失配：`j += per`（统一大步长）

#### 4.3.2 安全上界的几何推导

- 非周期分支的核心问题是：既然没有精确周期，如何确定一个安全的跳跃步长？

- **安全上界公式**：
```c
per = MAX(ell + 1, m - ell - 1) + 1;
```
  - `ell + 1` = L 的长度
  - `m - ell - 1` = R 的长度
  - 取两者较大值再加 1

- **前置说明**：上一轮匹配可能是全匹配或 R 匹配，可靠的镜像区只有曾匹配的 R。以下分类讨论中，"镜像区"指文本中已与 R 匹配的区域。

- **情况1：L 比 R 长或相等**

```
模式串:  |----- L -----|-- R --|
         0            ell     m-1
位移后:                |----- L -----|-- R --|   位移 d = |L|
位移后:            |----- L -----|-- R --|       位移 d < |L|
                          ↑ 镜像区落入 L 内部
```

  - 假设位移 d < |L|，位移后，镜像区会落入 L 内部。
  - 如果能形成合法匹配，意味着 L 的某个子串 = 镜像区 = R。
  - 但 maxSuf 保证：R 是最大后缀（或反序最大后缀，取决于方向），L 中不可能有与 R 相等的子串，否则最大后缀起点会在 L 内部。
  - 矛盾。所以 d < |L| 不安全。
  - 假设位移 d = |L|，L 的首字符会对齐镜像区的首字符。
  - 如果能形成合法匹配，意味着 L 的前缀等于 R，同样与最大后缀性质矛盾。
  - 所以 d = |L| 也不安全。
  - 结论：必须 per = |L| + 1，完整跳过 L 后再多跳一个字符，使得 L 对齐于镜像区的第二个字符。

- **情况2：R 比 L 长**

```
模式串:  |-- L --|----- R -----|
         0      ell           m-1
位移后:     |-- L --|----- R -----|              位移d较小
位移后:              |-- L --|----- R -----|     位移d较大，但位移d<|R|
位移后:                |-- L --|----- R -----|   位移d = |R|，此时 L = R_suffix
         
```

  - 因为 R 比 L 长，L 永远不会面对"未来字符"。位移 d ≤ |R| 时，分三种情况：

  - **情况 2.1**，较小的位移后，L 的后缀落入镜像区，L 的前缀在镜像区之前。
    - 如果能形成合法匹配，意味着 L 的后缀 = 镜像区前缀 = R 的前缀。
    - 但这意味着L中存在着真正的最大后缀起点，与R是最大后缀矛盾。

  - **情况 2.2**，L 完整落入镜像区内部（包括刚好在尾部）。

  - 如果能形成合法匹配，我们可以这样拆分模式串：（由最长串获胜原则，形成合法匹配不会违反最大后缀性质）
    - 模式串 = L + R_prefix + R_mid + L' + R_suffix
    - 由镜像区的传递作用：L + R_prefix = L' + R_suffix
    - 从而：R_prefix = R_suffix，L = L'
  - 这意味着 len(R_prefix + R_mid + L') 是 R 的一个周期，设为 n。
    - 回想 maxSuf 函数：R_suffix 这个挑战者将会一路打平直至退出 while 循环，因此 p 不会大于 n。
  - 设 p 为 maxSuf 返回的最小周期，则应 n ≥ p。
  - **若 n = p**：
    - memcmp(x, x+p, ell+1) 检查 L 是否等于 R 的对应子串。
    - 由于 L = L' 且 R_prefix = R_suffix，memcmp 应该成功。
    - 但我们进入了非周期分支，矛盾。
  - **若 n > p**：
    - 已知：p 是 R 的最小周期，前文已严格论证，R 位移小于 p 必定因镜像区约束而冲突，R 位移等于 p 则镜像区字符保持匹配。
    - L' + R_suffix 是镜像区的映射。对于镜像区而言，右移 p 或左移 p 均不会发生冲突。
    - 既然镜像区可以左移或右移 p，那么 L' + R_suffix 也可以左移或右移 p，若原先匹配，移动后应仍与镜像区匹配。
    - 左移 L' + R_suffix 一个周期 p，此时应仍匹配，则 n - p 仍是 R 的周期。
    - 持续左移，最终得到 n' < p 且 n' 是 R 的周期。
    - 这与"p 是最小周期"矛盾。
  - **结论**：假设匹配成功导致矛盾，任何位移都不安全。

- **周期差引理（数学补充）**：
  - 若某一区间同时允许长度为 p 与 n 的合法位移（即均不产生字符冲突），则长度 |n − p| 的位移同样不会产生字符冲突。
  - 因此多个合法周期可以不断相减，最终得到严格小于 p 的周期。
  - 这正是上述"若 n > p，持续左移最终得到 n' < p"的数学依据。

- **统一结论**：
  - 情况1证明了：当 L 更长时，任何 d ≤ |L| 的位移都必字符冲突。
  - 情况2证明了：当 R 更长时，任何 d ≤ |R| 的位移都必字符冲突。
  - 因此，`per = MAX(|L|, |R|) + 1` 是保证不漏匹配的最小安全步长。

#### 4.3.3 R 失配：与周期分支共享的逻辑

- 非周期分支中，R 失配时的位移策略与周期分支完全一致：

```c
j += (i - ell);
```

- **为什么可以复用同一套逻辑？**
  - R 失配位移的推导前提：
    1. ell 由双向最大后缀共同确定
    2. 镜像区内"短跳必冲突"的几何关系
  - 这两点**不依赖**"模式串具有周期性"这一条件，因此周期分支和非周期分支可以共享同一套位移逻辑。

- **关键洞察**：
  - R 失配位移 `i - ell` 的安全性，仅依赖于 `ell` 的双向极值约束
  - 这一约束在周期分支和非周期分支中都成立
  - 因此，非周期分支在 R 失配路径上同样可以"大胆跳跃"

#### 4.3.4 两种分支的位移策略对比

- 周期分支与非周期分支在位移策略上的本质区别：

| 场景 | 周期分支 | 非周期分支 |
|------|----------|------------|
| R 失配 | `j += (i - ell)` | `j += (i - ell)` |
| 完整匹配 | `j += per` (精确周期) | `j += per` (安全上界) |
| 左半部失配 | `j += per` + memory | `j += per` (无 memory) |

- **位移大小的几何对比**：

```
周期分支的 per:
- 来自 maxSuf 的精确周期，重叠区可复用
- 例: P = "abcabc", ell = 1, per = 3

非周期分支的 per:
- 来自长度计算的安全上界
- 例: P = "abcdeab", ell = 3, per = MAX(4, 3) + 1 = 5
```

#### 4.3.5 小结：非周期分支的设计哲学

- 非周期分支的职责可概括为：
  - **前提**：memcmp 表明精确周期信息不可靠
  - **安全上界计算**：`per = MAX(ell + 1, m - ell - 1) + 1`
  - **R 失配路径**：与周期分支完全相同
    - 位移：`j += (i - ell)`
    - 原因：R 失配位移的推导仅依赖双向最大后缀性质，不依赖周期性
  - **成功/左失配路径**：
    - 位移：`j += per`（使用安全上界而非精确周期）
    - 无 memory 优化（因为无法保证重叠区可复用）
  - **复杂度保证**：O(n)，每个文本位置最多被比较常数次

- **周期分支 vs 非周期分支**：

周期分支处理"好字符串"（周期性明确）：利用精确周期复用重叠区，memory 机制跳过已验证前缀。

非周期分支处理"坏字符串"（周期性不可靠）：使用安全上界保证不漏配，放弃 memory 但保持线性复杂度。

两者的核心差异在于：周期分支依赖精确周期信息，非周期分支在周期信息不可靠时退守到安全上界。

## 五、总结

### 5.1 核心流程

预处理阶段：
1. maxSuf / maxSufTilde 分别在两种字典序下寻找最大后缀，得到 i, j 和对应的 p, q
2. ell = max(i, j)，per = 对应的 p 或 q
3. memcmp(x, x+per, ell+1) 判断周期性：
   - 相等 → 周期分支，per 为精确周期，启用 memory 优化
   - 不等 → 非周期分支，per = MAX(|L|, |R|) + 1（安全上界）

搜索阶段：
1. 右半部比较（从 ell+1 到 m-1）：失配则 `j += (i - ell)`，memory = -1
2. 左半部回溯（从 ell 向下到 0）：周期分支中因 memory >= ell，条件 `i > memory` 为假，直接跳过
3. 成功或左失配后：`j += per`，memory = m - per - 1

### 5.2 关键结论

- **临界分解**：任意字符串存在切分点 ell，其局部周期等于全局周期（但未必是靠右切分点）
- **安全跳跃**：per 是"不触发矛盾的最小平移单位"
- **周期分支**：memcmp 验证后，精确周期可用于复用重叠区（memory 优化）
- **非周期分支**：周期信息不可靠时，退守安全上界保证不漏配
- **复杂度**：预处理 O(m)，搜索 O(n)，空间 O(1)

### 5.3 与其他算法对比

Two-Way 的核心优势是 O(1) 空间复杂度，适合内存受限场景，且在周期串上有专门优化。相比 KMP 的 O(m) 空间和 Boyer-Moore 的 O(m + |Σ|) 空间，Two-Way 在保证 O(n) 时间的同时实现了常数空间。

## 版权说明

- 本文遵循 MIT 许可证
- 欢迎转载，请注明来源
- 欢迎提出问题和建议
